<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Block Blast – SpinnerRealYT Games</title>

<link rel="icon" type="image/png" href="../Logo.png">
<link rel="apple-touch-icon" href="../Logo.png">

<style>
:root {
  --bg: #020617;
  --card: #0f172a;
  --accent: #38bdf8;
  --text: #e5e7eb;
  --cell-size: clamp(32px, 9vw, 45px);
  --gap: 4px;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: Inter, system-ui, sans-serif;
  background: radial-gradient(circle at top, #020617, #000);
  color: var(--text);
  overflow: hidden;
  user-select: none;
  touch-action: none;
}
header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 20px; background: rgba(15,23,42,.9);
  backdrop-filter: blur(10px); position: relative; z-index: 100;
}
header img { height: 32px; }
header button {
  background: rgba(56,189,248,.1); border: 1px solid var(--accent);
  color: var(--text); padding: 6px 15px; border-radius: 8px; cursor: pointer;
}

main { max-width: 500px; margin: auto; padding: 10px; }
.card {
  background: linear-gradient(180deg, #0f172a, #020617);
  border-radius: 20px; padding: 15px; box-shadow: 0 10px 40px rgba(0,0,0,.6);
}
#score { text-align: center; font-size: 22px; font-weight: bold; margin-bottom: 15px; color: var(--accent); }

#board {
  display: grid;
  grid-template-columns: repeat(9, var(--cell-size));
  grid-template-rows: repeat(9, var(--cell-size));
  gap: var(--gap);
  justify-content: center;
  margin: 0 auto;
  background: rgba(255,255,255,0.05);
  padding: 8px;
  border-radius: 10px;
  width: fit-content;
  position: relative;
}
.cell { width: var(--cell-size); height: var(--cell-size); background: #1e293b; border-radius: 4px; }

#next-blocks {
  display: flex; justify-content: space-around; align-items: center;
  margin-top: 25px; min-height: 120px;
}
/* Klocki w menu są lekko mniejsze, żeby zmieścić 3 obok siebie */
.block { display: grid; cursor: grab; touch-action: none; transform: scale(0.7); transition: transform 0.1s; }
.block-cell { width: var(--cell-size); height: var(--cell-size); border-radius: 4px; }

.ghost-cell {
  position: absolute; width: var(--cell-size); height: var(--cell-size);
  border-radius: 4px; opacity: 0.4; pointer-events: none; z-index: 5;
  display: none;
}
footer { text-align: center; opacity: .6; padding: 15px; font-size: 11px; }
</style>
</head>
<body>

<header>
  <img src="../Logo.png" alt="Logo">
  <button onclick="location.href='../index.html'">Menu</button>
</header>

<main>
  <div class="card">
    <div id="score">Punkty: 0</div>
    <div id="board"></div>
    <div id="next-blocks"></div>
  </div>
</main>

<footer>© 2026 SpinnerRealYT Games</footer>

<script>
const ROWS = 9, COLS = 9;
const COLORS = ["#38bdf8", "#4ade80", "#fb7185", "#fbbf24", "#a78bfa", "#2dd4bf"];
const SHAPES = [
  [[1,1,1,1]], [[1],[1],[1],[1]], [[1,1],[1,1]], 
  [[1,1,1],[0,1,0]], [[1,1,0],[0,1,1]], [[1,0],[1,0],[1,1]],
  [[1,1,1]], [[1,1],[1,0]], [[1]]
];

const boardEl = document.getElementById("board");
const nextEl = document.getElementById("next-blocks");
const scoreEl = document.getElementById("score");

let board = [], score = 0, currentBlocks = [];

function getBoardMetrics() {
  const firstCell = boardEl.querySelector('.cell');
  if(!firstCell) return { left: 0, top: 0, step: 0, padding: 0 };
  const rect = boardEl.getBoundingClientRect();
  const cellSize = firstCell.getBoundingClientRect().width;
  const gap = parseFloat(getComputedStyle(boardEl).gap) || 0;
  const padding = parseFloat(getComputedStyle(boardEl).paddingLeft) || 0;
  return { left: rect.left, top: rect.top, step: cellSize + gap, padding };
}

function init() {
  board = Array.from({length: ROWS}, () => Array(COLS).fill(null));
  boardEl.innerHTML = "";
  for(let r=0; r<ROWS; r++) {
    for(let c=0; c<COLS; c++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.id = `cell-${r}-${c}`;
      boardEl.appendChild(cell);
    }
  }
  score = 0;
  updateScore();
  generateNext();
}

function updateScore() { scoreEl.textContent = "Punkty: " + score; }

function generateNext() {
  nextEl.innerHTML = "";
  currentBlocks = [];
  for(let i=0; i<3; i++) {
    const shape = SHAPES[Math.floor(Math.random()*SHAPES.length)];
    const color = COLORS[Math.floor(Math.random()*COLORS.length)];
    const blockId = "block-" + Date.now() + "-" + i;
    
    const blockDiv = document.createElement("div");
    blockDiv.className = "block";
    blockDiv.id = blockId;
    blockDiv.style.gridTemplateColumns = `repeat(${shape[0].length}, var(--cell-size))`;
    blockDiv.style.gap = "2px";
    
    shape.forEach(row => {
      row.forEach(val => {
        const sq = document.createElement("div");
        sq.className = "block-cell";
        if(val) sq.style.background = color;
        else sq.style.background = "transparent";
        blockDiv.appendChild(sq);
      });
    });

    nextEl.appendChild(blockDiv);
    currentBlocks.push({id: blockId, shape, color});
    makeDraggable(blockDiv, blockId);
  }
}

function makeDraggable(blockEl, blockId) {
  function startDrag(clientX, clientY) {
    const blockData = currentBlocks.find(b => b.id === blockId);
    if(!blockData) return;
    const {shape, color} = blockData;

    const metrics = getBoardMetrics();
    const rect = blockEl.getBoundingClientRect();
    
    const offsetX = clientX - rect.left;
    const offsetY = clientY - rect.top;

    // Po podniesieniu powiększamy klocek do skali 1:1 z planszą
    blockEl.style.transform = "scale(1)";
    blockEl.style.position = "fixed";
    blockEl.style.zIndex = "1000";
    blockEl.style.pointerEvents = "none";

    let ghosts = [];
    shape.forEach((row, r) => {
      row.forEach((val, c) => {
        if(val) {
          const g = document.createElement("div");
          g.className = "ghost-cell";
          g.style.background = color;
          boardEl.appendChild(g);
          ghosts.push({el: g, r, c});
        }
      });
    });

    function move(ev) {
      const x = ev.clientX ?? (ev.touches ? ev.touches[0].clientX : 0);
      const y = ev.clientY ?? (ev.touches ? ev.touches[0].clientY : 0);

      // Przesunięcie klocka w górę o 70px (więcej niż poprzednio dla lepszej widoczności)
      const visualYOffset = 70;
      blockEl.style.left = (x - offsetX) + "px";
      blockEl.style.top = (y - offsetY - visualYOffset) + "px";

      const col = Math.round((x - metrics.left - offsetX - metrics.padding) / metrics.step);
      const row = Math.round((y - metrics.top - offsetY - visualYOffset - metrics.padding) / metrics.step);

      if(canPlace(row, col, shape)) {
        ghosts.forEach(g => {
          g.el.style.display = "block";
          g.el.style.left = ( (col + g.c) * metrics.step + metrics.padding ) + "px";
          g.el.style.top = ( (row + g.r) * metrics.step + metrics.padding ) + "px";
        });
      } else {
        ghosts.forEach(g => g.el.style.display = "none");
      }
    }

    function end(ev) {
      const x = ev.clientX ?? (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
      const y = ev.clientY ?? (ev.changedTouches ? ev.changedTouches[0].clientY : 0);

      document.removeEventListener("mousemove", move);
      document.removeEventListener("mouseup", end);
      document.removeEventListener("touchmove", move);
      document.removeEventListener("touchend", end);

      const visualYOffset = 70;
      const col = Math.round((x - metrics.left - offsetX - metrics.padding) / metrics.step);
      const row = Math.round((y - metrics.top - offsetY - visualYOffset - metrics.padding) / metrics.step);

      if(canPlace(row, col, shape)) {
        placeBlock(row, col, shape, color);
        blockEl.remove();
        currentBlocks = currentBlocks.filter(b => b.id !== blockId);
        if(currentBlocks.length === 0) generateNext();
        else checkGameOver();
      } else {
        blockEl.style.position = "";
        blockEl.style.zIndex = "";
        blockEl.style.pointerEvents = "auto";
        blockEl.style.transform = "scale(0.7)";
      }
      ghosts.forEach(g => g.el.remove());
    }

    document.addEventListener("mousemove", move);
    document.addEventListener("mouseup", end);
    document.addEventListener("touchmove", move, {passive:false});
    document.addEventListener("touchend", end);
  }

  blockEl.addEventListener("mousedown", e => { e.preventDefault(); startDrag(e.clientX, e.clientY); });
  blockEl.addEventListener("touchstart", e => { e.preventDefault(); startDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
}

function canPlace(r, c, shape) {
  for(let dr=0; dr<shape.length; dr++) {
    for(let dc=0; dc<shape[0].length; dc++) {
      if(shape[dr][dc]) {
        const nr = r + dr, nc = c + dc;
        if(nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS || board[nr][nc]) return false;
      }
    }
  }
  return true;
}

function placeBlock(r, c, shape, color) {
  shape.forEach((rowArr, dr) => {
    rowArr.forEach((val, dc) => {
      if(val) board[r+dr][c+dc] = color;
    });
  });
  updateBoardUI();
  clearLines();
}

function updateBoardUI() {
  for(let r=0; r<ROWS; r++) {
    for(let c=0; c<COLS; c++) {
      const cell = document.getElementById(`cell-${r}-${c}`);
      cell.style.background = board[r][c] || "#1e293b";
    }
  }
}

function clearLines() {
  let rowsToClear = [], colsToClear = [];
  for(let r=0; r<ROWS; r++) if(board[r].every(cell => cell !== null)) rowsToClear.push(r);
  for(let c=0; c<COLS; c++) if(board.every(row => row[c] !== null)) colsToClear.push(c);

  rowsToClear.forEach(r => board[r].fill(null));
  colsToClear.forEach(c => { for(let r=0; r<ROWS; r++) board[r][c] = null; });

  if(rowsToClear.length > 0 || colsToClear.length > 0) {
    score += (rowsToClear.length + colsToClear.length) * 10;
    updateScore();
    setTimeout(updateBoardUI, 150);
  }
}

function checkGameOver() {
  const canAnyMove = currentBlocks.some(block => {
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        if(canPlace(r, c, block.shape)) return true;
      }
    }
    return false;
  });

  if(!canAnyMove) {
    setTimeout(() => {
      alert("Koniec gry! Wynik: " + score);
      init();
    }, 500);
  }
}

init();
</script>

</body>
</html>
