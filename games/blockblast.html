<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Block Blast – SpinnerRealYT Games</title>
<style>
:root{
  --bg:#020617;
  --card:#0f172a;
  --accent:#38bdf8;
  --text:#e5e7eb;
  /* Dynamiczne obliczanie rozmiaru komórki */
  --cell-size: clamp(30px, 8vw, 45px); 
  --grid-gap: 4px;
}
*{box-sizing:border-box;}
body{
  margin:0;
  font-family:Inter,system-ui,sans-serif;
  background:radial-gradient(circle at top,#020617,#000);
  color:var(--text);
  overflow: hidden;
  user-select: none;
  touch-action: none;
}
header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 15px;
  background:rgba(15,23,42,.9);
  backdrop-filter:blur(10px);
  z-index:100;
}
header img{height:30px;}
header button{
  background:rgba(56,189,248,.1); border:1px solid var(--accent); color:var(--text);
  font-size:14px; padding:6px 12px; border-radius:8px; cursor:pointer;
}

main{
  width: 100%;
  max-width: 500px;
  margin: auto;
  padding: 10px;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.card{
  width: 100%;
  background:linear-gradient(180deg,#0f172a,#020617);
  border-radius:20px;
  padding:15px;
  box-shadow:0 10px 40px rgba(0,0,0,.6);
}
h2{text-align:center; margin:0 0 5px 0; font-size: 1.2rem;}
#score{
  text-align:center;
  font-size:20px;
  font-weight:bold;
  margin-bottom:10px;
  color: var(--accent);
}

/* KONTENER PLANSZY */
#board{
  display:grid;
  grid-template-columns:repeat(9, var(--cell-size));
  grid-template-rows:repeat(9, var(--cell-size));
  gap:var(--grid-gap);
  justify-content:center;
  margin: 0 auto;
  background: rgba(255,255,255,0.05);
  padding: 8px;
  border-radius: 10px;
  width: fit-content;
}
.cell{
  width:var(--cell-size);
  height:var(--cell-size);
  background:#1e293b;
  border-radius:4px;
}

/* KLOCKI DO WYBORU */
#next-blocks{
  display:flex;
  justify-content:space-around;
  align-items: center;
  margin-top:20px;
  min-height: 120px;
  width: 100%;
}
.block{
  display:grid;
  cursor: grab;
  touch-action: none;
  /* Skalowanie klocków na dole, żeby były mniejsze */
  transform: scale(0.8);
}
.block-cell{
  width:var(--cell-size);
  height:var(--cell-size);
  border-radius:4px;
}
.ghost-cell{
  position:absolute;
  width:var(--cell-size);
  height:var(--cell-size);
  border-radius:4px;
  opacity:0.4;
  pointer-events:none;
  z-index:5;
  display: none;
}
footer{ text-align:center; opacity:.6; padding:10px; font-size: 10px; }
</style>
</head>
<body>

<header>
<img src="../Logo.png" alt="Logo">
<button onclick="location.href='../index.html'">Menu</button>
</header>

<main>
<div class="card">
  <div id="score">Punkty: 0</div>
  <div id="board"></div>
  <div id="next-blocks"></div>
</div>
</main>

<footer>
© 2026 SpinnerRealYT Games
</footer>

<script>
// Pobieramy realny rozmiar z CSS, aby JS wiedział jak przesuwać klocki
function getCellSize() {
  const temp = document.createElement('div');
  temp.style.width = "var(--cell-size)";
  document.body.appendChild(temp);
  const size = parseFloat(getComputedStyle(temp).width);
  const gap = 4; // var(--grid-gap)
  document.body.removeChild(temp);
  return size + gap;
}

let GRID_STEP = getCellSize();
window.addEventListener('resize', () => { GRID_STEP = getCellSize(); });

const ROWS=9, COLS=9;
const COLORS=["#38bdf8", "#4ade80", "#fb7185", "#fbbf24", "#a78bfa", "#2dd4bf"];
const SHAPES=[
  [[1,1,1,1]], [[1],[1],[1],[1]], [[1,1],[1,1]], 
  [[1,1,1],[0,1,0]], [[1,1,0],[0,1,1]], [[1,0],[1,0],[1,1]],
  [[1,1,1]], [[1,1],[1,0]], [[1]]
];

const boardEl=document.getElementById("board");
const nextEl=document.getElementById("next-blocks");
const scoreEl=document.getElementById("score");

let board=[], score=0, currentBlocks=[];

function init(){
  board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
  boardEl.innerHTML="";
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell=document.createElement("div");
      cell.className="cell";
      cell.id = `cell-${r}-${c}`;
      boardEl.appendChild(cell);
    }
  }
  score=0;
  updateScore();
  generateNext();
}

function updateScore(){ scoreEl.textContent="Punkty: "+score; }

function generateNext(){
  nextEl.innerHTML="";
  currentBlocks=[];
  for(let i=0;i<3;i++){
    const shape=SHAPES[Math.floor(Math.random()*SHAPES.length)];
    const color=COLORS[Math.floor(Math.random()*COLORS.length)];
    const blockId = "b-" + Date.now() + "-" + i;
    
    const blockDiv=document.createElement("div");
    blockDiv.className="block";
    blockDiv.id = blockId;
    blockDiv.style.gridTemplateColumns=`repeat(${shape[0].length}, var(--cell-size))`;
    blockDiv.style.gap = "2px";
    
    shape.forEach(row => {
      row.forEach(val => {
        const sq=document.createElement("div");
        sq.className="block-cell";
        if(val) sq.style.background=color;
        else sq.style.background="transparent";
        blockDiv.appendChild(sq);
      });
    });

    nextEl.appendChild(blockDiv);
    currentBlocks.push({id: blockId, shape, color});
    makeDraggable(blockDiv, blockId);
  }
}

function makeDraggable(blockEl, blockId){
  function startDrag(clientX, clientY) {
    const blockData = currentBlocks.find(b => b.id === blockId);
    if(!blockData) return;
    const {shape, color} = blockData;

    const rect = blockEl.getBoundingClientRect();
    // Offset musi brać pod uwagę środek klocka dla lepszego wrażenia na dotyk
    const offsetX = clientX - rect.left;
    const offsetY = clientY - rect.top;

    // Reset skali przy przeciąganiu
    blockEl.style.transform = "scale(1)";

    let localGhosts = [];
    for(let r=0; r<shape.length; r++){
      for(let c=0; c<shape[0].length; c++){
        if(shape[r][c]){
          const g = document.createElement("div");
          g.className = "ghost-cell";
          g.style.background = color;
          boardEl.appendChild(g);
          localGhosts.push({el: g, r, c});
        }
      }
    }

    blockEl.style.position = "fixed";
    blockEl.style.zIndex = "1000";
    blockEl.style.pointerEvents = "none";

    function move(ev){
      const x = ev.clientX ?? (ev.touches ? ev.touches[0].clientX : 0);
      const y = ev.clientY ?? (ev.touches ? ev.touches[0].clientY : 0);

      // Przesunięcie klocka nieco wyżej nad palec, żeby gracz widział co kładzie
      blockEl.style.left = (x - offsetX) + "px";
      blockEl.style.top = (y - offsetY - 50) + "px";

      const boardRect = boardEl.getBoundingClientRect();
      // Obliczanie pozycji względem siatki (z uwzględnieniem offsetu palca)
      const col = Math.round((x - boardRect.left - offsetX - 8) / GRID_STEP);
      const row = Math.round((y - boardRect.top - offsetY - 58) / GRID_STEP);

      if(canPlace(row, col, shape)){
        localGhosts.forEach(g => {
          g.el.style.display = "block";
          g.el.style.left = (col + g.c) * GRID_STEP + 8 + "px";
          g.el.style.top = (row + g.r) * GRID_STEP + 8 + "px";
        });
      } else {
        localGhosts.forEach(g => g.el.style.display = "none");
      }
    }

    function end(ev){
      const x = ev.clientX ?? (ev.changedTouches ? ev.changedTouches[0].clientX : 0);
      const y = ev.clientY ?? (ev.changedTouches ? ev.changedTouches[0].clientY : 0);

      document.removeEventListener("mousemove", move);
      document.removeEventListener("mouseup", end);
      document.removeEventListener("touchmove", move);
      document.removeEventListener("touchend", end);

      const boardRect = boardEl.getBoundingClientRect();
      const col = Math.round((x - boardRect.left - offsetX - 8) / GRID_STEP);
      const row = Math.round((y - boardRect.top - offsetY - 58) / GRID_STEP);

      if(canPlace(row, col, shape)){
        placeBlock(row, col, shape, color);
        blockEl.remove();
        currentBlocks = currentBlocks.filter(b => b.id !== blockId);
        if(currentBlocks.length === 0) generateNext();
        else checkGameOver();
      } else {
        blockEl.style.position = "";
        blockEl.style.zIndex = "";
        blockEl.style.pointerEvents = "auto";
        blockEl.style.left = "";
        blockEl.style.top = "";
        blockEl.style.transform = "scale(0.8)";
      }
      localGhosts.forEach(g => g.el.remove());
    }

    document.addEventListener("mousemove", move);
    document.addEventListener("mouseup", end);
    document.addEventListener("touchmove", move, {passive:false});
    document.addEventListener("touchend", end);
  }

  blockEl.addEventListener("mousedown", e => { e.preventDefault(); startDrag(e.clientX, e.clientY); });
  blockEl.addEventListener("touchstart", e => { e.preventDefault(); startDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
}

function canPlace(r, c, shape){
  for(let dr=0; dr<shape.length; dr++){
    for(let dc=0; dc<shape[0].length; dc++){
      if(shape[dr][dc]){
        const nr = r + dr, nc = c + dc;
        if(nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS || board[nr][nc]) return false;
      }
    }
  }
  return true;
}

function placeBlock(r, c, shape, color){
  shape.forEach((rowArr, dr) => {
    rowArr.forEach((val, dc) => {
      if(val) board[r+dr][c+dc] = color;
    });
  });
  updateBoardUI();
  clearLines();
}

function updateBoardUI(){
  for(let r=0; r<ROWS; r++){
    for(let c=0; c<COLS; c++){
      const cell = document.getElementById(`cell-${r}-${c}`);
      cell.style.background = board[r][c] || "#1e293b";
    }
  }
}

function clearLines(){
  let rowsToClear = [], colsToClear = [];
  for(let r=0; r<ROWS; r++) if(board[r].every(cell => cell !== null)) rowsToClear.push(r);
  for(let c=0; c<COLS; c++) if(board.every(row => row[c] !== null)) colsToClear.push(c);

  rowsToClear.forEach(r => board[r].fill(null));
  colsToClear.forEach(c => { for(let r=0; r<ROWS; r++) board[r][c] = null; });

  if(rowsToClear.length > 0 || colsToClear.length > 0){
    score += (rowsToClear.length + colsToClear.length) * 10;
    updateScore();
    setTimeout(updateBoardUI, 150);
  }
}

function checkGameOver(){
  const canAnyMove = currentBlocks.some(block => {
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        if(canPlace(r, c, block.shape)) return true;
      }
    }
    return false;
  });

  if(!canAnyMove){
    setTimeout(() => {
      alert("Koniec gry! Wynik: " + score);
      init();
    }, 500);
  }
}

init();
</script>

</body>
</html>
