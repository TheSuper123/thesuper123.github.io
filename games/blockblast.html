<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Block Blast â€“ SpinnerRealYT Games</title>
<style>
:root{
  --bg:#020617;
  --card:#0f172a;
  --accent:#38bdf8;
  --text:#e5e7eb;
  --cell:40px;
  --gap:4px;
}
*{box-sizing:border-box;}
body{
  margin:0;
  font-family:Inter,system-ui,sans-serif;
  background:radial-gradient(circle at top,#020617,#000);
  color:var(--text);
  overflow: hidden;
  user-select: none;
  touch-action: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: start;
  height: 100vh;
  width: 100vw;
}
header{
  display:flex;
  align-items:center;
  justify-content:flex-start;
  padding:15px 20px;
  background:rgba(15,23,42,.9);
  backdrop-filter:blur(10px);
  z-index:100;
  width:100%;
}
header img{height:42px;margin-right:20px;}
header button{
  background:none; border:none; color:var(--text);
  font-size:15px; padding:8px 14px; border-radius:10px; cursor:pointer;
}
header button:hover{ background:rgba(56,189,248,.15); color:var(--accent); }

main{
  flex:1;
  display:flex;
  justify-content:center;
  align-items:center;
  width:100%;
  overflow:hidden;
}
.card{
  background:linear-gradient(180deg,#0f172a,#020617);
  border-radius:20px;
  padding:20px;
  box-shadow:0 20px 60px rgba(0,0,0,.6);
  position: relative;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  transform-origin: top center;
}
h2{text-align:center;margin:0 0 10px 0; font-size:1.5em;}
#score{
  text-align:center;
  font-size:24px;
  font-weight:bold;
  margin-bottom:15px;
  color: var(--accent);
}
#board{
  display:grid;
  grid-template-columns:repeat(9, var(--cell));
  grid-template-rows:repeat(9, var(--cell));
  gap: var(--gap);
  justify-content:center;
  position:relative;
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
}
.cell{
  width: var(--cell);
  height: var(--cell);
  background:#1e293b;
  border-radius:4px;
}
#next-blocks{
  display:flex;
  justify-content:center;
  align-items: center;
  gap:40px;
  margin-top:20px;
}
.block{
  display:grid;
  cursor: grab;
  user-select:none;
  touch-action: none;
}
.block-cell{
  width: var(--cell);
  height: var(--cell);
  border-radius:4px;
}
.ghost-cell{
  position:absolute;
  width: var(--cell);
  height: var(--cell);
  border-radius:4px;
  opacity:0.4;
  pointer-events:none;
  z-index:5;
  display: none;
}
footer{ text-align:center; opacity:.6; padding:20px; font-size: 12px; width:100%; }

</style>
</head>
<body>

<header>
<img src="../Logo.png" alt="SpinnerRealYT">
<button onclick="location.href='../index.html'">Menu</button>
</header>

<main>
<div class="card" id="card">
<h2>ðŸŸ¦ Block Blast 9x9</h2>
<div id="score">Punkty: 0</div>
<div id="board"></div>
<div id="next-blocks"></div>
</div>
</main>

<footer>
Â© 2026 SpinnerRealYT Games
</footer>

<script>
let ROWS=9, COLS=9;
let COLORS=["#38bdf8", "#4ade80", "#fb7185", "#fbbf24", "#a78bfa", "#2dd4bf"];
let SHAPES=[
  [[1,1,1,1]], [[1],[1],[1],[1]], [[1,1],[1,1]], 
  [[1,1,1],[0,1,0]], [[1,1,0],[0,1,1]], [[1,0],[1,0],[1,1]],
  [[1,1,1]], [[1,1],[1,0]], [[1]]
];

const boardEl=document.getElementById("board");
const nextEl=document.getElementById("next-blocks");
const scoreEl=document.getElementById("score");
const cardEl=document.getElementById("card");

let board=[], score=0, currentBlocks=[];

// --- SKALOWANIE ---
function scaleCard(){
  const w = window.innerWidth*0.95;
  const h = window.innerHeight*0.8;
  const cellSize = Math.min(Math.floor(w/9), Math.floor(h/9));
  document.documentElement.style.setProperty('--cell', cellSize + 'px');
  document.documentElement.style.setProperty('--gap', Math.max(Math.floor(cellSize*0.05),2) + 'px');
  const boardWidth = 9*cellSize + 8*parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
  const boardHeight = 9*cellSize + 8*parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
  const scaleX = w/boardWidth;
  const scaleY = h/boardHeight;
  cardEl.style.transform = `scale(${Math.min(scaleX,scaleY)})`;
}
window.addEventListener("resize", scaleCard);
window.addEventListener("orientationchange", scaleCard);

// --- GRA ---
function init(){
  board=Array.from({length:ROWS},()=>Array(COLS).fill(null));
  boardEl.innerHTML="";
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell=document.createElement("div");
      cell.className="cell";
      cell.id = `cell-${r}-${c}`;
      boardEl.appendChild(cell);
    }
  }
  score=0;
  updateScore();
  generateNext();
  scaleCard();
}

function updateScore(){ scoreEl.textContent="Punkty: "+score; }

function generateNext(){
  nextEl.innerHTML="";
  currentBlocks=[];
  for(let i=0;i<3;i++){
    const shape=SHAPES[Math.floor(Math.random()*SHAPES.length)];
    const color=COLORS[Math.floor(Math.random()*COLORS.length)];
    const blockId = Date.now() + "-" + i;
    
    const blockDiv=document.createElement("div");
    blockDiv.className="block";
    blockDiv.id = blockId;
    blockDiv.style.gridTemplateColumns=`repeat(${shape[0].length}, var(--cell))`;
    blockDiv.style.gap = "2px";
    
    shape.forEach(row => {
      row.forEach(val => {
        const sq=document.createElement("div");
        sq.className="block-cell";
        if(val) sq.style.background=color;
        else sq.style.background="transparent";
        blockDiv.appendChild(sq);
      });
    });

    nextEl.appendChild(blockDiv);
    currentBlocks.push({id: blockId, shape, color});
    makeDraggable(blockDiv, blockId);
  }
}

function makeDraggable(blockEl, blockId){
  function startDrag(clientX, clientY){
    const blockData = currentBlocks.find(b => b.id === blockId);
    if(!blockData) return;
    const {shape, color} = blockData;
    const rect = blockEl.getBoundingClientRect();
    const offsetX = clientX - rect.left;
    const offsetY = clientY - rect.top;

    let ghosts=[];
    for(let r=0;r<shape.length;r++){
      for(let c=0;c<shape[0].length;c++){
        if(shape[r][c]){
          const g=document.createElement("div");
          g.className="ghost-cell";
          g.style.background=color;
          boardEl.appendChild(g);
          ghosts.push({el:g,r,c});
        }
      }
    }

    blockEl.style.position="fixed";
    blockEl.style.zIndex="1000";
    blockEl.style.pointerEvents="none";

    function move(ev){
      let x = ev.clientX ?? ev.touches[0].clientX;
      let y = ev.clientY ?? ev.touches[0].clientY;

      blockEl.style.left = (x - offsetX) + "px";
      blockEl.style.top = (y - offsetY) + "px";

      const boardRect = boardEl.getBoundingClientRect();
      const gridStep = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell')) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
      const col = Math.round((x - boardRect.left - offsetX - 10)/gridStep);
      const row = Math.round((y - boardRect.top - offsetY - 10)/gridStep);

      if(canPlace(row,col,shape)){
        ghosts.forEach(g=>{
          g.el.style.display="block";
          g.el.style.left = (col+g.c)*gridStep + 10 + "px";
          g.el.style.top = (row+g.r)*gridStep + 10 + "px";
        });
      }else{
        ghosts.forEach(g=>g.el.style.display="none");
      }
    }

    function end(ev){
      let x = ev.clientX ?? ev.changedTouches[0].clientX;
      let y = ev.clientY ?? ev.changedTouches[0].clientY;

      document.removeEventListener("mousemove",move);
      document.removeEventListener("mouseup",end);
      document.removeEventListener("touchmove",move);
      document.removeEventListener("touchend",end);

      const boardRect = boardEl.getBoundingClientRect();
      const gridStep = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell')) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
      const col = Math.round((x - boardRect.left - offsetX - 10)/gridStep);
      const row = Math.round((y - boardRect.top - offsetY - 10)/gridStep);

      if(canPlace(row,col,shape)){
        placeBlock(row,col,shape,color);
        blockEl.remove();
        currentBlocks=currentBlocks.filter(b=>b.id!==blockId);
        if(currentBlocks.length===0) generateNext();
        else checkGameOver();
      }else{
        blockEl.style.position="";
        blockEl.style.zIndex="";
        blockEl.style.pointerEvents="auto";
        blockEl.style.left="";
        blockEl.style.top="";
      }

      ghosts.forEach(g=>g.el.remove());
    }

    document.addEventListener("mousemove",move);
    document.addEventListener("mouseup",end);
    document.addEventListener("touchmove",move,{passive:false});
    document.addEventListener("touchend",end);
  }

  blockEl.addEventListener("mousedown", e=>{e.preventDefault(); startDrag(e.clientX,e.clientY);});
  blockEl.addEventListener("touchstart", e=>{e.preventDefault(); startDrag(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
}

function canPlace(r,c,shape){
  for(let dr=0;dr<shape.length;dr++){
    for(let dc=0;dc<shape[0].length;dc++){
      if(shape[dr][dc]){
        const nr=r+dr,nc=c+dc;
        if(nr<0||nr>=ROWS||nc<0||nc>=COLS||board[nr][nc]) return false;
      }
    }
  }
  return true;
}

function placeBlock(r,c,shape,color){
  shape.forEach((rowArr,dr)=>{
    rowArr.forEach((val,dc)=>{
      if(val) board[r+dr][c+dc]=color;
    });
  });
  updateBoardUI();
  clearLines();
}

function updateBoardUI(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell=document.getElementById(`cell-${r}-${c}`);
      cell.style.background=board[r][c]||"#1e293b";
    }
  }
}

function clearLines(){
  let rowsToClear=[],colsToClear=[];
  for(let r=0;r<ROWS;r++) if(board[r].every(cell=>cell!==null)) rowsToClear.push(r);
  for(let c=0;c<COLS;c++) if(board.every(row=>row[c]!==null)) colsToClear.push(c);

  rowsToClear.forEach(r=>board[r].fill(null));
  colsToClear.forEach(c=>{for(let r=0;r<ROWS;r++) board[r][c]=null;});

  if(rowsToClear.length>0||colsToClear.length>0){
    score+=(rowsToClear.length+colsToClear.length)*10;
    updateScore();
    setTimeout(updateBoardUI,150);
  }
}

function checkGameOver(){
  const canAnyMove=currentBlocks.some(block=>{
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(canPlace(r,c,block.shape)) return true;
      }
    }
    return false;
  });

  if(!canAnyMove){
    setTimeout(()=>{alert("Koniec gry! Wynik: "+score);init();},500);
  }
}

init();
</script>

</body>
</html>
